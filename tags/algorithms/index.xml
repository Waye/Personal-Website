<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithms on </title>
    <link>https://weiyi-hu.com/tags/algorithms/</link>
    <description>Recent content in Algorithms on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 17 Mar 2023 02:24:00 +0000</lastBuildDate><atom:link href="https://weiyi-hu.com/tags/algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>刷题(二)</title>
      <link>https://weiyi-hu.com/2023/03/17/Subarray-Sum-Prefix-Sum/</link>
      <pubDate>Fri, 17 Mar 2023 02:24:00 +0000</pubDate>
      
      <guid>https://weiyi-hu.com/2023/03/17/Subarray-Sum-Prefix-Sum/</guid>
      <description>Conditions Prefix sum is a powerful pre-processing/ caching technique for algorithm problems. The idea is to calculate/store the consecutive totals of the elements in an array in O(n). Questions 304 class NumMatrix { // To achieve O(1) time complexity for sumRegion, we can use a precomputation technique called prefix sum. We can calculate a 2D prefix sum matrix where each element in the matrix represents the sum of all elements</description>
    </item>
    
    <item>
      <title>刷题(一)</title>
      <link>https://weiyi-hu.com/2023/03/13/merge-interval/</link>
      <pubDate>Mon, 13 Mar 2023 23:06:00 +0000</pubDate>
      
      <guid>https://weiyi-hu.com/2023/03/13/merge-interval/</guid>
      <description>Conditions Questions 56 class Solution { public int[][] merge(int[][] intervals) { //sort Arrays.sort(intervals, Comparator.comparingInt(a -&amp;gt; a[0])); List&amp;lt;int[]&amp;gt; merged = new ArrayList&amp;lt;&amp;gt;(); for(int[]interval:intervals){ //empty(),arraylist get last element =merged.size()-1 if( merged.isEmpty() || merged.get(merged.size()-1)[1] &amp;lt; interval[0]){ merged.add(interval); }else if(merged.get(merged.size()-1)[1] &amp;gt;= interval[0] ){ merged.get(merged.size()-1)[1] = Math.max(merged.get(merged.size()-1)[1],interval[1] ); } } //toArray(new int[][]) return merged.toArray(new int[merged.size()][2]); } } Arrays.sort(intervals, Comparator.comparingInt(a -&amp;gt; a[0])); Arrays.sort(intervals, (a, b) -&amp;gt; Integer.compare(a[0], b[0])); 57 class Solution { public int[][] insert(int[][] intervals,</description>
    </item>
    
  </channel>
</rss>
